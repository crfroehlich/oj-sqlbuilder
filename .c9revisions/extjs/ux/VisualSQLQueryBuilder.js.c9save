{"ts":1367454380856,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"Ext.define('Ext.ux.window.visualsqlquerybuilder.SQLTableSprite', {\r\n    extend: 'Ext.draw.Sprite',\r\n    alias: ['widget.sqltablesprite'],\r\n    bConnections: false,\r\n    startDrag: function(id){\r\n        var me = this, win, sqlTablePanel, xyParentPos, xyChildPos;\r\n\r\n        // get a reference to a sqltable\r\n        win = Ext.getCmp(id);\r\n\r\n        // get the main sqlTablePanel\r\n        sqlTablePanel = Ext.getCmp('SQLTablePanel');\r\n\r\n        // get the main sqlTablePanel position\r\n        xyParentPos = sqlTablePanel.el.getXY();\r\n\r\n        // get the size of the previously added sqltable\r\n        xyChildPos = win.el.getXY();\r\n\r\n        me.prev = me.surface.transformToViewBox(xyChildPos[0] - xyParentPos[0] + 2, xyChildPos[1] - xyParentPos[1] + 2);\r\n    },\r\n\r\n    onDrag: function(relPosMovement){\r\n        var xy, me = this, attr = this.attr, newX, newY;\r\n        // move the sprite\r\n        // calculate new x and y position\r\n        newX = me.prev[0] + relPosMovement[0];\r\n        newY = me.prev[1] + relPosMovement[1];\r\n        // set new x and y position and redraw sprite\r\n        me.setAttributes({\r\n            x: newX,\r\n            y: newY\r\n\r\n        }, true);\r\n    }\r\n});\r\n\r\nExt.define('Ext.ux.window.visualsqlquerybuilder.SQLTableModel', {\r\n    extend: 'Ext.data.Model',\r\n    fields: [{\r\n        name: 'id',\r\n        type: 'string'\r\n    }, {\r\n        name: 'tableName',\r\n        type: 'string'\r\n    }, {\r\n        name: 'tableAlias',\r\n        type: 'string'\r\n    }]\r\n});\r\n\r\nExt.define('Ext.ux.window.visualsqlquerybuilder.SQLTableStore', {\r\n    extend: 'Ext.data.Store',\r\n    autoSync: true,\r\n    model: 'Ext.ux.window.visualsqlquerybuilder.SQLTableModel',\r\n    proxy: {\r\n        type: 'memory'\r\n    }\r\n});\r\n\r\nExt.define('Ext.ux.window.visualsqlquerybuilder.SQLJoin', {\r\n    extend: 'Ext.data.Model',\r\n    fields: [{\r\n        name: 'id',\r\n        type: 'string'\r\n    }, {\r\n        name: 'leftTableId',\r\n        type: 'string'\r\n    }, {\r\n        name: 'rightTableId',\r\n        type: 'string'\r\n    }, {\r\n        name: 'leftTableField',\r\n        type: 'string'\r\n    }, {\r\n        name: 'rightTableField',\r\n        type: 'string'\r\n    }, {\r\n        name: 'joinCondition',\r\n        type: 'string'\r\n    }, {\r\n        name: 'joinType',\r\n        type: 'string'\r\n    }],\r\n    createUUID: function(){\r\n        // http://www.ietf.org/rfc/rfc4122.txt\r\n        var s = [];\r\n        var hexDigits = \"0123456789abcdef\";\r\n        for (var i = 0; i < 36; i++) {\r\n            s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);\r\n        }\r\n        s[14] = \"4\"; // bits 12-15 of the time_hi_and_version field to 0010\r\n        s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1); // bits 6-7 of the clock_seq_hi_and_reserved to 01\r\n        s[8] = s[13] = s[18] = s[23] = \"-\";\r\n\r\n        var uuid = s.join(\"\");\r\n        return uuid;\r\n    }\r\n});\r\n\r\nExt.define('Ext.ux.window.visualsqlquerybuilder.JoinStore', {\r\n    extend: 'Ext.data.Store',\r\n    autoSync: true,\r\n    model: 'Ext.ux.window.visualsqlquerybuilder.SQLJoin',\r\n    proxy: {\r\n        type: 'memory'\r\n    }\r\n});\r\n\r\nExt.define('Ext.ux.window.visualsqlquerybuilder.SQLFieldsModel', {\r\n    extend: 'Ext.data.Model',\r\n    fields: [{\r\n        name: 'id',\r\n        type: 'string'\r\n    }, {\r\n        name: 'tableName',\r\n        type: 'string'\r\n    }, {\r\n        name: 'tableId',\r\n        type: 'string'\r\n    }, {\r\n        name: 'extCmpId',\r\n        type: 'string'\r\n    }, {\r\n        name: 'tableAlias',\r\n        type: 'string'\r\n    }, {\r\n        name: 'field',\r\n        type: 'string'\r\n    }, {\r\n        name: 'output',\r\n        type: 'boolean'\r\n    }, {\r\n        name: 'expression',\r\n        type: 'string'\r\n    }, {\r\n        name: 'aggregate',\r\n        type: 'string'\r\n    }, {\r\n        name: 'alias',\r\n        type: 'string'\r\n    }, {\r\n        name: 'sortType',\r\n        type: 'string'\r\n    }, {\r\n        name: 'sortOrder',\r\n        type: 'int'\r\n    }, {\r\n        name: 'grouping',\r\n        type: 'boolean'\r\n    }, {\r\n        name: 'criteria',\r\n        type: 'string'\r\n    }]\r\n});\r\n\r\nExt.define('Ext.ux.window.visualsqlquerybuilder.SQLFieldsStore', {\r\n    extend: 'Ext.data.Store',\r\n    autoSync: true,\r\n    model: 'Ext.ux.window.visualsqlquerybuilder.SQLFieldsModel',\r\n    proxy: {\r\n        type: 'memory'\r\n    }\r\n});\r\n\r\nExt.define('Ext.ux.window.visualsqlquerybuilder.SQLSelect', {\r\n    config: {\r\n        tables: '',\r\n        fields: '',\r\n        joins: ''\r\n    },\r\n    constructor: function(){\r\n\r\n        this.tables = Ext.create('Ext.ux.window.visualsqlquerybuilder.SQLTableStore', {\r\n            storeId: 'SQLTableStore'\r\n        });\r\n\r\n        // handle all updates on sql tables\r\n        this.tables.on('update', this.handleSQLTableUpdate, this);\r\n        this.tables.on('add', this.handleSQLTableAdd, this);\r\n        this.tables.on('remove', this.handleSQLTableRemove, this);\r\n\r\n        this.fields = Ext.create('Ext.ux.window.visualsqlquerybuilder.SQLFieldsStore', {\r\n            storeId: 'SQLFieldsStore'\r\n        });\r\n\r\n        this.fields.on('update', this.handleSQLFieldChanges, this);\r\n        this.fields.on('remove', this.handleSQLFieldRemove, this);\r\n\r\n        this.joins = Ext.create('Ext.ux.window.visualsqlquerybuilder.JoinStore', {\r\n            storeId: 'JoinStore'\r\n        });\r\n\r\n        // this.joins.on('update', this.handleSQLJoinChanges, this);\r\n        this.joins.on('add', this.handleSQLJoinChanges, this);\r\n        this.joins.on('remove', this.handleSQLJoinChanges, this);\r\n\r\n        this.callParent(arguments);\r\n    },\r\n    handleSQLTableUpdate: function(tableStore, table, operation){\r\n        if (operation == 'commit') {\r\n            this.updateFieldTableData(table);\r\n            this.updateJoinTableData(table);\r\n            this.updateSQLOutput();\r\n        }\r\n    },\r\n    handleSQLTableAdd: function(tableStore, table, index){\r\n        this.updateSQLOutput();\r\n    },\r\n    handleSQLTableRemove: function(tableStore, table, index){\r\n        var aJoins = [];\r\n        // get table joins and remove them\r\n        aJoins = this.getJoinsByTableId(table.get('id'));\r\n        // loop over the joins array\r\n        for (var i = 0, l = aJoins.length; i < l; i++) {\r\n            // remove join from store\r\n            this.removeJoinById(aJoins[i].get('id'));\r\n        }\r\n        this.updateSQLOutput();\r\n    },\r\n    handleSQLJoinChanges: function(joinStore, join){\r\n        this.updateSQLOutput();\r\n    },\r\n    updateFieldTableData: function(table){\r\n        var tableId, expression, tableAlias, tableName;\r\n        tableId = table.get('id');\r\n        tableAlias = table.get('tableAlias');\r\n        tableName = table.get('tableName');\r\n        // loop over all fields of the fields store\r\n        this.fields.each(function(field){\r\n            // check if current field belongs to sql table\r\n            if (field.get('tableId') == tableId) {\r\n                if (tableAlias != '') {\r\n                    // we have a table alias\r\n                    expression = tableAlias + '.' + field.get('field');\r\n                }\r\n                else {\r\n                    // no table alias\r\n                    expression = tableName + '.' + field.get('field');\r\n                };\r\n                field.beginEdit();\r\n                // update the field table alias\r\n                field.set('tableAlias', tableAlias);\r\n                // update the field expression\r\n                field.set('expression', expression);\r\n                field.commit(true);\r\n                field.endEdit();\r\n            }\r\n        });\r\n        return;\r\n    },\r\n    updateJoinTableData: function(table){\r\n        var joins, tableId;\r\n        tableId = table.get('id');\r\n        joins = this.getJoinsByTableId(tableId);\r\n        for (var i = 0, rightTable, leftTable, joinCondition = '',l = joins.length; i < l; i++) {\r\n            leftTable = this.getTableById(joins[i].get('leftTableId'));\r\n            rightTable = this.getTableById(joins[i].get('rightTableId'));\r\n\r\n            if (leftTable.get('tableAlias') != '') {\r\n                joinCondition = joinCondition + leftTable.get('tableAlias') + '.' + joins[i].get('leftTableField') + '=';\r\n            }\r\n            else {\r\n                joinCondition = joinCondition + leftTable.get('tableName') + '.' + joins[i].get('leftTableField') + '=';\r\n            }\r\n\r\n            if (rightTable.get('tableAlias') != '') {\r\n                joinCondition = joinCondition + rightTable.get('tableAlias') + '.' + joins[i].get('rightTableField');\r\n            }\r\n            else {\r\n                joinCondition = joinCondition + rightTable.get('tableName') + '.' + joins[i].get('rightTableField');\r\n            }\r\n            joins[i].beginEdit();\r\n            joins[i].set('joinCondition', joinCondition);\r\n            joins[i].commit(true);\r\n            joins[i].endEdit();\r\n        }\r\n    },\r\n    handleSQLFieldChanges: function(fieldStore, model, operation){\r\n        if (operation == 'commit') {\r\n            this.updateSQLOutput();\r\n        }\r\n    },\r\n    handleSQLFieldRemove: function(fieldStore){\r\n        this.updateSQLOutput();\r\n    },\r\n    updateSQLOutput: function(){\r\n        var sqlOutput, sqlHTML, sqlQutputPanel;\r\n        sqlOutput = this.toString();\r\n        sqlHTML = '<pre class=\"brush: sql\">' + sqlOutput + '</pre>';\r\n        sqlQutputPanel = Ext.getCmp('SQLOutputPanel');\r\n\r\n        sqlQutputPanel.update(sqlHTML);\r\n    },\r\n    sortTablesByJoins: function(tables, oUsedTables){\r\n        var aTables = [], aJoins = [], oUsedTables = oUsedTables ||\r\n        {};\r\n        // loop over tables\r\n        for (var i = 0, aCondition = [], aJoin, l = tables.length; i < l; i++) {\r\n            // check if current table is a new one\r\n            if (!oUsedTables.hasOwnProperty(tables[i].get('id'))) {\r\n                // it is a new one\r\n                aTables.push(tables[i]);\r\n                // mark table as used\r\n                oUsedTables[tables[i].get('id')] = true;\r\n                // get any joins for the current table\r\n                aJoin = this.getJoinsByTableId(tables[i].get('id'));\r\n                // loop over the join tables\r\n                for (var j = 0, joinTable, len = aJoin.length; j < len; j++) {\r\n                    // check if it is a new join\r\n                    if (!oUsedTables.hasOwnProperty(aJoin[j].get('id'))) {\r\n                        // mark join as used\r\n                        oUsedTables[aJoin[j].get('id')] = true;\r\n                        if (tables[i].get('id') != aJoin[j].get('leftTableId')) {\r\n                            joinTable = this.getTableById(aJoin[j].get('leftTableId'));\r\n                            this.changeLeftRightOnJoin(aJoin[j]);\r\n                        }\r\n                        else {\r\n                            joinTable = this.getTableById(aJoin[j].get('rightTableId'));\r\n                        }\r\n                        oTemp = this.sortTablesByJoins([joinTable], oUsedTables);\r\n                        oUsedTables = oTemp.oUsedTables;\r\n                        aTables = aTables.concat(oTemp.aTables);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            aTables: aTables,\r\n            oUsedTables: oUsedTables\r\n        };\r\n    },\r\n    changeLeftRightOnJoin: function(join){\r\n        var leftTable, leftTableField, rightTable, rightTableField, joinCondition = '';\r\n        // prepare new data\r\n        leftTable = this.getTableById(join.get('rightTableId'));\r\n        leftTableField = join.get('rightTableField');\r\n        rightTable = this.getTableById(join.get('leftTableId'));\r\n        rightTableField = join.get('leftTableField');\r\n\r\n        // construct new joinCondition\r\n        if (leftTable.get('tableAlias') != '') {\r\n            joinCondition = joinCondition + leftTable.get('tableAlias') + '.' + join.get('rightTableField') + '=';\r\n        }\r\n        else {\r\n            joinCondition = joinCondition + leftTable.get('tableName') + '.' + join.get('rightTableField') + '=';\r\n        }\r\n\r\n        if (rightTable.get('tableAlias') != '') {\r\n            joinCondition = joinCondition + rightTable.get('tableAlias') + '.' + join.get('leftTableField');\r\n        }\r\n        else {\r\n            joinCondition = joinCondition + rightTable.get('tableName') + '.' + join.get('leftTableField');\r\n        }\r\n\r\n        // start transaction\r\n        join.beginEdit();\r\n        // change left and right join table data\r\n        join.set('leftTableId', leftTable.get('id'));\r\n        join.set('leftTableField', leftTableField);\r\n        join.set('rightTableId', rightTable.get('id'));\r\n        join.set('rightTableField', rightTableField);\r\n        join.set('joinCondition', joinCondition);\r\n        // silent commit without firing store events\r\n        // this prevents endless loop\r\n        join.commit(true);\r\n        join.endEdit();\r\n        // end transaction\r\n        return;\r\n    },\r\n    toString: function(){\r\n        var sqlOutput = 'SELECT ', aJoins = [], aOutputFields = [], oJoinTables = {}, aTables = [], aJoinTables = [], aCriteriaFields = [], aGroupFields = [], aOrderFields = [], selectFieldsSQL = '', fromSQL = '', aFromSQL = [], criteriaSQL = '', orderBySQL = '', groupBySQL = '', fieldSeperator = ', ', joinSQL = '', bFirst = true, bPartOfJoin = false;\r\n        this.fields.each(function(field){\r\n            // should the field be a part of the output\r\n            if (field.get('output')) {\r\n                aOutputFields.push(field);\r\n            }\r\n            // any criteria\r\n            if (field.get('criteria') != '') {\r\n                aCriteriaFields.push(field);\r\n            }\r\n            // check for grouping\r\n            if (field.get('grouping')) {\r\n                aGroupFields.push(field);\r\n            }\r\n            // check for sorting\r\n            if (field.get('sortType') != '') {\r\n                aOrderFields.push(field);\r\n            }\r\n        });\r\n\r\n        // tables\r\n        // sorting of tables\r\n        this.tables.each(function(table){\r\n            aTables.push(table);\r\n        });\r\n\r\n        aTables = this.sortTablesByJoins(aTables).aTables;\r\n\r\n\r\n        this.joins.each(function(join){\r\n            aJoins.push(join);\r\n        });\r\n\r\n        //create fromSQL\r\n        for (var k = 0, aJoin = [], oJoinTables = {}, joinCondition = '', joinType, leftTable, rightTable, l = aTables.length; k < l; k++) {\r\n            if (k == aTables.length - 1) {\r\n                fieldSeperator = '';\r\n            }\r\n            else {\r\n                fieldSeperator = ', ';\r\n            };\r\n\r\n            // is the current table the first one\r\n            if (bFirst) {\r\n                // yes it is the first\r\n\r\n                // table id merken\r\n                oJoinTables[aTables[k].get('id')] = true;\r\n\r\n                bFirst = false;\r\n\r\n                // check if current table is not the last one in the loop\r\n                if ((k + 1) < aTables.length) {\r\n                    // get joins where joins leftTableID is a property of oJoinTables and joins rightTableID equal to aTables[i+1].get('id')\r\n                    for (var h = 0, len = aJoins.length; h < len; h++) {\r\n                        if (oJoinTables.hasOwnProperty(aJoins[h].get('leftTableId')) && aJoins[h].get('rightTableId') == aTables[k + 1].get('id')) {\r\n                            aJoin.push(aJoins[h]);\r\n                        }\r\n                        if (oJoinTables.hasOwnProperty(aJoins[h].get('rightTableId')) && aJoins[h].get('leftTableId') == aTables[k + 1].get('id')) {\r\n                            this.changeLeftRightOnJoin(aJoins[h]);\r\n                            aJoin.push(aJoins[h]);\r\n                        }\r\n                    }\r\n\r\n                    // check if we have a join\r\n                    if (aJoin.length > 0) {\r\n                        // yes we have a join between aTables[k] and aTables[k+1] with at least one join condition\r\n\r\n                        leftTable = aTables[k];\r\n                        rightTable = aTables[k + 1];\r\n\r\n                        // table id merken\r\n                        oJoinTables[rightTable.get('id')] = true;\r\n\r\n                        for (var j = 0, fieldSeperator = '', ln = aJoin.length; j < ln; j++) {\r\n                            if (j == aJoin.length - 1) {\r\n                                fieldSeperator = '';\r\n                            }\r\n                            else {\r\n                                fieldSeperator = '\\nAND ';\r\n                            };\r\n                            joinType = aJoin[j].get('joinType');\r\n                            joinCondition = joinCondition + aJoin[j].get('joinCondition') + fieldSeperator;\r\n                        }\r\n\r\n                        // reset the join array\r\n                        aJoin = [];\r\n\r\n                        if (joinSQL != '') {\r\n                            joinSQL = joinSQL + ',\\n';\r\n                        }\r\n\r\n                        if (leftTable.get('tableAlias') != '') {\r\n                            // we have an leftTable alias\r\n                            joinSQL = joinSQL + leftTable.get('tableName') + ' ' + leftTable.get('tableAlias') + ' ' + joinType + ' JOIN ';\r\n                        }\r\n                        else {\r\n                            //no alias\r\n                            joinSQL = joinSQL + leftTable.get('tableName') + ' ' + joinType + ' JOIN ';\r\n                        }\r\n\r\n                        if (rightTable.get('tableAlias') != '') {\r\n                            // we have an rightTable alias\r\n                            joinSQL = joinSQL + rightTable.get('tableName') + ' ' + rightTable.get('tableAlias') + ' ON ' + joinCondition;\r\n                        }\r\n                        else {\r\n                            //no alias\r\n                            joinSQL = joinSQL + rightTable.get('tableName') + ' ON ' + joinCondition;\r\n                        }\r\n\r\n                        // clear joinCondition\r\n                        joinCondition = '';\r\n\r\n                    }\r\n                    else {\r\n                        // no join between aTables[i+1] and the one before\r\n                        bFirst = true;\r\n                        oJoinTables = {};\r\n                        // check for tableAlias\r\n                        if (aTables[k].get('tableAlias') != '') {\r\n                            fromSQL = aTables[k].get('tableName') + ' ' + aTables[k].get('tableAlias');\r\n                        }\r\n                        else {\r\n                            fromSQL = aTables[k].get('tableName');\r\n                        }\r\n                        aFromSQL.push(fromSQL);\r\n                    }\r\n                }\r\n                else {\r\n                    // its the last and only one in the loop\r\n                    // check for tableAlias\r\n                    if (aTables[k].get('tableAlias') != '') {\r\n                        fromSQL = aTables[k].get('tableName') + ' ' + aTables[k].get('tableAlias');\r\n                    }\r\n                    else {\r\n                        fromSQL = aTables[k].get('tableName');\r\n                    }\r\n                    aFromSQL.push(fromSQL);\r\n                }\r\n            }\r\n            else {\r\n                // no, it is not the first table\r\n\r\n                bFirst = true;\r\n\r\n                // check if current table is not the last one in the loop\r\n                if ((k + 1) < aTables.length) {\r\n                    // get joins where joins leftTableID is a property of oJoinTables and joins rightTableID equal to aTables[i+1].get('id')\r\n                    for (var h = 0, len = aJoins.length; h < len; h++) {\r\n                        if (oJoinTables.hasOwnProperty(aJoins[h].get('leftTableId')) && aJoins[h].get('rightTableId') == aTables[k + 1].get('id')) {\r\n                            aJoin.push(aJoins[h]);\r\n                        }\r\n                        if (oJoinTables.hasOwnProperty(aJoins[h].get('rightTableId')) && aJoins[h].get('leftTableId') == aTables[k + 1].get('id')) {\r\n                            this.changeLeftRightOnJoin(aJoins[h]);\r\n                            aJoin.push(aJoins[h]);\r\n                        }\r\n                    }\r\n\r\n                    // check if we have a join\r\n                    if (aJoin.length > 0) {\r\n                        // yes we have a join between aTables[k] and aTables[k+1] with at least one join condition\r\n\r\n                        rightTable = aTables[k + 1];\r\n\r\n                        // table id merken\r\n                        oJoinTables[rightTable.get('id')] = true;\r\n\r\n                        for (var j = 0, fieldSeperator = '', ln = aJoin.length; j < ln; j++) {\r\n                            if (j == aJoin.length - 1) {\r\n                                fieldSeperator = '';\r\n                            }\r\n                            else {\r\n                                fieldSeperator = '\\nAND ';\r\n                            };\r\n                            joinType = aJoin[j].get('joinType');\r\n                            joinCondition = joinCondition + aJoin[j].get('joinCondition') + fieldSeperator;\r\n                        }\r\n\r\n                        // reset the join array\r\n                        aJoin = [];\r\n\r\n                        bFirst = false;\r\n\r\n                        if (rightTable.get('tableAlias') != '') {\r\n                            // we have an rightTable alias\r\n                            joinSQL = joinSQL + '\\n' + joinType + ' JOIN ' + rightTable.get('tableName') + ' ' + rightTable.get('tableAlias') + ' ON ' + joinCondition;\r\n                        }\r\n                        else {\r\n                            //no alias\r\n                            joinSQL = joinSQL + '\\n' + joinType + ' JOIN ' + rightTable.get('tableName') + ' ON ' + joinCondition;\r\n                        }\r\n\r\n                        // clear joinCondition\r\n                        joinCondition = '';\r\n                    }\r\n                    else {\r\n                        bFirst = true;\r\n                        oJoinTables = {};\r\n                    }\r\n                }\r\n                else {\r\n                    // its the last and only one\r\n                    // check for tableAlias\r\n                    oJoinTables = {};\r\n                }\r\n            }\r\n        }\r\n\r\n        fromSQL = aFromSQL.join(', ');\r\n\r\n        if (joinSQL != '' && fromSQL != '') {\r\n            joinSQL = joinSQL + ', ';\r\n        }\r\n\r\n        fromSQL = '\\nFROM ' + joinSQL + fromSQL;\r\n\r\n        // output fields\r\n        for (var i = 0, l = aOutputFields.length; i < l; i++) {\r\n            // check if it is the last array member\r\n            if (i == aOutputFields.length - 1) {\r\n                fieldSeperator = '';\r\n            }\r\n            else {\r\n                fieldSeperator = ', ';\r\n            };\r\n            // yes, output\r\n            // check alias\r\n            if (aOutputFields[i].get('alias') != '') {\r\n                // yes, we have an field alias\r\n                selectFieldsSQL = selectFieldsSQL + aOutputFields[i].get('expression') + ' AS ' + aOutputFields[i].get('alias') + fieldSeperator;\r\n            }\r\n            else {\r\n                // no field alias\r\n                selectFieldsSQL = selectFieldsSQL + aOutputFields[i].get('expression') + fieldSeperator;\r\n            }\r\n        }\r\n\r\n        // criteria\r\n        for (var i = 0, l = aCriteriaFields.length; i < l; i++) {\r\n            if (i == 0) {\r\n                criteriaSQL = criteriaSQL + '\\nWHERE ';\r\n            }\r\n            else {\r\n                criteriaSQL = criteriaSQL + 'AND ';\r\n            }\r\n            if (i == aCriteriaFields.length - 1) {\r\n                fieldSeperator = '';\r\n            }\r\n            else {\r\n                fieldSeperator = '\\n';\r\n            }\r\n            criteriaSQL = criteriaSQL + aCriteriaFields[i].get('expression') + ' ' + aCriteriaFields[i].get('criteria') + fieldSeperator;\r\n        }\r\n\r\n        // group by\r\n        for (var i = 0, l = aGroupFields.length; i < l; i++) {\r\n            // check if it is the last array member\r\n            if (i == aGroupFields.length - 1) {\r\n                fieldSeperator = '';\r\n            }\r\n            else {\r\n                fieldSeperator = ', ';\r\n            }\r\n            if (i == 0) {\r\n                groupBySQL = '\\nGROUP BY ';\r\n            }\r\n            groupBySQL = groupBySQL + aGroupFields[i].get('expression') + fieldSeperator;\r\n        }\r\n\r\n        // order by\r\n        for (var i = 0, l = aOrderFields.length; i < l; i++) {\r\n            // check if it is the last array member\r\n            if (i == aOrderFields.length - 1) {\r\n                fieldSeperator = '';\r\n            }\r\n            else {\r\n                fieldSeperator = ', ';\r\n            }\r\n        }\r\n\r\n        return sqlOutput + selectFieldsSQL + fromSQL + criteriaSQL + groupBySQL + orderBySQL;\r\n    },\r\n    getJoinsByTableId: function(tableId){\r\n        var aReturn = [];\r\n        this.joins.each(function(join){\r\n            if (join.get('leftTableId') == tableId || join.get('rightTableId') == tableId) {\r\n                aReturn.push(join);\r\n            }\r\n        });\r\n        return aReturn;\r\n    },\r\n    removeTableById: function(tableID){\r\n        var table;\r\n        table = this.tables.getById(tableID);\r\n        this.tables.remove(table);\r\n    },\r\n    getTableById: function(tableID){\r\n        return this.tables.getById(tableID);\r\n    },\r\n    removeFieldById: function(id){\r\n        var field;\r\n        field = this.fields.getById(id);\r\n        this.fields.remove(field);\r\n    },\r\n    removeFieldsByTableId: function(tableId){\r\n        var aRecords = [];\r\n        this.fields.each(function(model){\r\n            if (model.get('tableId') == tableId) {\r\n                aRecords.push(model);\r\n            }\r\n        });\r\n        this.fields.remove(aRecords);\r\n    },\r\n    addTable: function(table){\r\n        this.tables.add(table);\r\n    },\r\n    addFieldRecord: function(record, bOutput){\r\n        var tableAlias, model, expression;\r\n        // get the tableAlias\r\n        tableAlias = this.getTableById(record.get('tableId')).get('tableAlias');\r\n        // build the expression\r\n        // check if the tableAlias is not an empty string\r\n        if (tableAlias != '') {\r\n            // alias is not an empty string\r\n            expression = tableAlias + '.' + record.get('field');\r\n        }\r\n        else {\r\n            // alias is an empty string\r\n            expression = record.get('tableName') + '.' + record.get('field');\r\n        };\r\n        // get a new field instance\r\n        model = this.getNewField();\r\n        // set the expression\r\n        model.set('expression', expression);\r\n        // set output to false per default\r\n        model.set('output', bOutput);\r\n        // set an id, so it is possible to remove rows if the associated table is removed\r\n        model.set('id', record.get('id'));\r\n        // set the field\r\n        model.set('field', record.get('field'));\r\n        // copy tableId to the new model instance\r\n        model.set('tableId', record.get('tableId'));\r\n        // copy cmp id of origin sqltable to the new model instance\r\n        model.set('extCmpId', record.get('extCmpId'));\r\n        this.addField(model);\r\n    },\r\n    addField: function(field){\r\n        this.fields.add(field);\r\n    },\r\n    getNewField: function(){\r\n        return Ext.create('Ext.ux.window.visualsqlquerybuilder.SQLFieldsModel');\r\n    },\r\n    removeJoinById: function(joinID){\r\n        var join;\r\n        join = this.joins.getById(joinID);\r\n        this.joins.remove(join);\r\n    },\r\n    addJoin: function(join){\r\n        this.joins.add(join);\r\n    },\r\n    arrayRemove: function(array, filterProperty, filterValue){\r\n        var aReturn;\r\n        aReturn = Ext.Array.filter(array, function(item){\r\n            var bRemove = true;\r\n            if (item[filterProperty] == filtervalue) {\r\n                bRemove = false;\r\n            }\r\n            return bRemove;\r\n        });\r\n        return aReturn\r\n    }\r\n});\r\n\r\nExt.define('Ext.ux.window.visualsqlquerybuilder.SQLTablePanel', {\r\n    extend: 'Ext.panel.Panel',\r\n    alias: ['widget.sqltablepanel'],\r\n    id: 'SQLTablePanel',\r\n    items: [{\r\n        xtype: 'draw',\r\n        listeners: {\r\n            afterrender: function(){\r\n                this.initDropTarget();\r\n            }\r\n        },\r\n        initDropTarget: function(){\r\n            // init draw component inside qbwindow as a DropTarget\r\n            this.dropTarget = Ext.create('Ext.dd.DropTarget', this.el, {\r\n                ddGroup: 'sqlDDGroup',\r\n                notifyDrop: function(source, event, data){\r\n                    var sqlTablePanel;\r\n                    // add a sqltable to the sqlTablePanel component\r\n                    sqlTablePanel = Ext.getCmp('SQLTablePanel');\r\n                    sqlTablePanel.add({\r\n                        xtype: 'sqltable',\r\n                        constrain: true,\r\n                        title: data.records[0].get('text')\r\n                    }).show();\r\n                    return true;\r\n                }\r\n            });\r\n        }\r\n    }]\r\n});\r\n\r\nExt.define('Ext.ux.window.visualsqlquerybuilder.SQLOutputPanel', {\r\n    extend: 'Ext.panel.Panel',\r\n    alias: ['widget.sqloutputpanel'],\r\n    id: 'SQLOutputPanel',\r\n    listeners: {\r\n        afterlayout: function(){\r\n            SyntaxHighlighter.highlight();\r\n        }\r\n    },\r\n    initComponent: function(){\r\n        this.callParent(arguments);\r\n    }\r\n});\r\n\r\nExt.define('Ext.ux.window.visualsqlquerybuilder.SQLFieldsGrid', {\r\n    requires: ['Ext.ux.CheckColumn'],\r\n    extend: 'Ext.grid.Panel',\r\n    alias: ['widget.sqlfieldsgrid'],\r\n    id: 'SQLFieldsGrid',\r\n    store: 'SQLFieldsStore',\r\n    columnLines: true,\r\n    plugins: [Ext.create('Ext.grid.plugin.CellEditing', {\r\n        clicksToEdit: 1\r\n    })],\r\n    viewConfig: {\r\n        listeners: {\r\n            render: function(view){\r\n                this.dd = {};\r\n                this.dd.dropZone = new Ext.grid.ViewDropZone({\r\n                    view: view,\r\n                    ddGroup: 'SQLTableGridDDGroup',\r\n                    handleNodeDrop: function(data, record, position){\r\n                        // Was soll nach dem Drop passieren?\r\n                    }\r\n                });\r\n            },\r\n            drop: function(node, data, dropRec, dropPosition){\r\n                // add new rows to the SQLFieldsGrid after a drop\r\n                for (var i = 0, l = data.records.length; i < l; i++) {\r\n                    ux.vqbuilder.sqlSelect.addFieldRecord(data.records[i], false);\r\n                }\r\n            }\r\n        }\r\n    },\r\n    columns: [{\r\n        xtype: 'actioncolumn',\r\n        menuDisabled: true,\r\n        text: 'Action',\r\n        width: 60,\r\n        moveGridRow: function(grid, record, index, direction){\r\n            var store = grid.getStore();\r\n            if (direction < 0) {\r\n                index--;\r\n                if (index < 0) {\r\n                    return;\r\n                }\r\n            }\r\n            else {\r\n                index++;\r\n                if (index >= grid.getStore().getCount()) {\r\n                    return;\r\n                }\r\n            }\r\n            // prepare manual syncing\r\n            store.suspendAutoSync();\r\n            // disable firing store events\r\n            store.suspendEvents();\r\n            // remove record and insert record at new index\r\n            store.remove(record);\r\n            store.insert(index, record);\r\n            // enable firing store events\r\n            store.resumeEvents();\r\n            store.resumeAutoSync();\r\n            // manual sync the store\r\n            store.sync();\r\n        },\r\n        items: [{\r\n            icon: 'resources/images/up_arrow.gif',\r\n            tooltip: 'Move Column Up',\r\n            getClass: function(value, metadata, record){\r\n                var store, index;\r\n                store = record.store;\r\n                index = store.indexOf(record);\r\n                if (index == 0) {\r\n                    return 'x-action-icon-disabled';\r\n                }\r\n                else {\r\n                    return 'x-grid-center-icon';\r\n                }\r\n            },\r\n            handler: function(grid, rowIndex, colIndex){\r\n                var rec = grid.getStore().getAt(rowIndex);\r\n                this.moveGridRow(grid, rec, rowIndex, -1);\r\n            }\r\n        }, {\r\n            icon: 'resources/images/down_arrow.gif',\r\n            getClass: function(value, metadata, record){\r\n                var store, index;\r\n                store = record.store;\r\n                index = store.indexOf(record);\r\n                if ((index + 1) == store.getCount()) {\r\n                    return 'x-action-icon-disabled';\r\n                }\r\n                else {\r\n                    return 'x-grid-center-icon';\r\n                }\r\n            },\r\n            tooltip: 'Move Column Down',\r\n            handler: function(grid, rowIndex, colIndex){\r\n                var rec = grid.getStore().getAt(rowIndex);\r\n                this.moveGridRow(grid, rec, rowIndex, 1);\r\n            }\r\n        }, {\r\n            icon: 'resources/images/remove.gif',\r\n            iconCls: 'x-grid-center-icon',\r\n            tooltip: 'Delete Column',\r\n            handler: function(grid, rowIndex, colIndex){\r\n                var rec = grid.getStore().getAt(rowIndex), store, tableId, tableGrid, selectionModel, bDel = true;\r\n                // rec contains column grid model, the one to remove\r\n                // get tableId of original sqltable\r\n                tableId = rec.get('extCmpId');\r\n                // get the sql tables grid and its selection\r\n                tableGrid = Ext.getCmp(tableId).down('gridpanel');\r\n                selectionModel = tableGrid.getSelectionModel();\r\n                Ext.Array.each(selectionModel.getSelection(), function(selection){\r\n                    // deselect the selection wich corresponds to the column\r\n                    // we want to remove from the column grid\r\n                    if (rec.get('id') == selection.get('id')) {\r\n                        // deselect current selection\r\n                        // deselection will lead to removal, look for method deselect at the SQLTableGrid\r\n                        selectionModel.deselect(selection);\r\n                        bDel = false;\r\n                    }\r\n                });\r\n                if (bDel) {\r\n                    store = grid.getStore();\r\n                    store.remove(rec);\r\n                }\r\n            }\r\n        }]\r\n    }, {\r\n        xtype: 'checkcolumn',\r\n        sortable: false,\r\n        text: 'Output',\r\n        flex: 0.075,\r\n        menuDisabled: true,\r\n        dataIndex: 'output',\r\n        align: 'center'\r\n    }, {\r\n        xtype: 'gridcolumn',\r\n        text: 'Expression',\r\n        sortable: false,\r\n        menuDisabled: true,\r\n        flex: 0.225,\r\n        dataIndex: 'expression',\r\n        editor: 'textfield'\r\n    }, {\r\n        xtype: 'gridcolumn',\r\n        text: 'Aggregate',\r\n        flex: 0.125,\r\n        sortable: false,\r\n        menuDisabled: true,\r\n        dataIndex: 'aggregate',\r\n        editor: 'textfield'\r\n    }, {\r\n        xtype: 'gridcolumn',\r\n        text: 'Alias',\r\n        flex: 0.125,\r\n        sortable: false,\r\n        menuDisabled: true,\r\n        dataIndex: 'alias',\r\n        editor: 'textfield'\r\n    }, {\r\n        xtype: 'gridcolumn',\r\n        text: 'Sort Type',\r\n        flex: 0.125,\r\n        sortable: false,\r\n        menuDisabled: true,\r\n        dataIndex: 'sorttype'\r\n    }, {\r\n        xtype: 'gridcolumn',\r\n        text: 'Sort Order',\r\n        flex: 0.125,\r\n        sortable: false,\r\n        menuDisabled: true,\r\n        dataIndex: 'sortorder'\r\n    }, {\r\n        xtype: 'checkcolumn',\r\n        text: 'Grouping',\r\n        flex: 0.075,\r\n        sortable: false,\r\n        menuDisabled: true,\r\n        dataIndex: 'grouping',\r\n        align: 'center'\r\n    }, {\r\n        xtype: 'gridcolumn',\r\n        text: 'Criteria',\r\n        flex: 0.125,\r\n        sortable: false,\r\n        menuDisabled: true,\r\n        dataIndex: 'criteria',\r\n        editor: 'textfield'\r\n    }],\r\n    initComponent: function(){\r\n        this.callParent(arguments);\r\n    }\r\n});\r\n\r\nExt.define('Ext.ux.window.visualsqlquerybuilder.SQLTableTree', {\r\n    extend: 'Ext.tree.Panel',\r\n    alias: ['widget.sqltabletree'],\r\n    id: 'SQLTableTree',\r\n    listeners: {\r\n        afterrender: function(){\r\n            this.initTreeDragZone();\r\n        },\r\n        itemdblclick: function(view, record, el, index, event){\r\n            var sqlTablePanel;\r\n            // add a sqltable to the sqlTablePanel component\r\n            sqlTablePanel = Ext.getCmp('SQLTablePanel');\r\n            sqlTablePanel.add({\r\n                xtype: 'sqltable',\r\n                constrain: true,\r\n                title: record.get('text')\r\n            }).show();\r\n\r\n        }\r\n    },\r\n    initTreeDragZone: function(){\r\n        // init tree view as a ViewDragZone\r\n        this.view.dragZone = new Ext.tree.ViewDragZone({\r\n            view: this.view,\r\n            ddGroup: 'sqlDDGroup',\r\n            dragText: '{0} ausgew√§hlte Tabelle{1}',\r\n            repairHighlightColor: 'c3daf9',\r\n            repairHighlight: Ext.enableFx\r\n        });\r\n    },\r\n    initComponent: function(){\r\n\r\n        this.store = Ext.create('Ext.data.TreeStore', {\r\n            root: {\r\n                text: 'Tables',\r\n                expanded: true,\r\n                children: [{ \"allowDrop\": false, \"text\": \"bestellpos\", \"leaf\": true }, { \"allowDrop\": false, \"text\": \"bestellung\", \"leaf\": true }, { \"allowDrop\": false, \"text\": \"bilder\", \"leaf\": true }, { \"allowDrop\": false, \"text\": \"category\", \"leaf\": true }, { \"allowDrop\": false, \"text\": \"categorynst\", \"leaf\": true }, { \"allowDrop\": false, \"text\": \"hersteller\", \"leaf\": true }, { \"allowDrop\": false, \"text\": \"histpreise\", \"leaf\": true }, { \"allowDrop\": false, \"text\": \"inventar\", \"leaf\": true }, { \"allowDrop\": false, \"text\": \"inventur\", \"leaf\": true }, { \"allowDrop\": false, \"text\": \"prod2cat\", \"leaf\": true }, { \"allowDrop\": false, \"text\": \"produkt\", \"leaf\": true }]\r\n            },\r\n            proxy: {\r\n                type: 'memory',\r\n                reader: {\r\n                    type: 'json'\r\n                }\r\n            }\r\n        });\r\n\r\n        this.callParent(arguments);\r\n    }\r\n});\r\n\r\n\r\nExt.define('Ext.ux.window.visualsqlquerybuilder.SQLTableGrid', {\r\n    extend: 'Ext.grid.Panel',\r\n    alias: ['widget.sqltablegrid'],\r\n    border: false,\r\n    hideHeaders: true,\r\n    viewConfig: {\r\n        listeners: {\r\n            bodyscroll: function(){\r\n                var scrollOffset, sqlTable;\r\n                // the bodyscroll event of the view was fired\r\n                // get scroll information\r\n                scrollOffset = this.el.getScroll();\r\n                // get the parent sqltable\r\n                sqlTable = this.up('sqltable');\r\n                // change shadowSprites scrollTop property\r\n                sqlTable.shadowSprite.scrollTop = scrollOffset.top;\r\n                // redraw all connections to reflect scroll action\r\n                for (var i = ux.vqbuilder.connections.length; i--;) {\r\n                    sqlTable.connection(ux.vqbuilder.connections[i]);\r\n                }\r\n            },\r\n            render: function(view){\r\n                this.dd = {};\r\n                // init the view as a DragZone\r\n                this.dd.dragZone = new Ext.view.DragZone({\r\n                    view: view,\r\n                    ddGroup: 'SQLTableGridDDGroup',\r\n                    dragText: '{0} selected table column{1}',\r\n                    onInitDrag: function(x, y){\r\n                        var me = this, data = me.dragData, view = data.view, selectionModel = view.getSelectionModel(), record = view.getRecord(data.item), e = data.event;\r\n                        data.records = [record];\r\n                        me.ddel.update(me.getDragText());\r\n                        me.proxy.update(me.ddel.dom);\r\n                        me.onStartDrag(x, y);\r\n                        return true;\r\n                    }\r\n                });\r\n                // init the view as a DropZone\r\n                this.dd.dropZone = new Ext.grid.ViewDropZone({\r\n                    view: view,\r\n                    ddGroup: 'SQLTableGridDDGroup',\r\n                    handleNodeDrop: function(data, record, position){\r\n                        // Was soll nach dem Drop passieren?\r\n                    },\r\n                    onNodeOver: function(node, dragZone, e, data){\r\n                        var me = this, view = me.view, pos = me.getPosition(e, node), overRecord = view.getRecord(node), draggingRecords = data.records;\r\n\r\n                        if (!Ext.Array.contains(data.records, me.view.getRecord(node))) {\r\n                            if (!Ext.Array.contains(draggingRecords, overRecord) && data.records[0].get('field') != '*') {\r\n                                me.valid = true;\r\n                                // valid drop target\r\n                                // todo show drop invitation\r\n                            }\r\n                            else {\r\n                                // invalid drop target\r\n                                me.valid = false;\r\n                            }\r\n                        }\r\n                        return me.valid ? me.dropAllowed : me.dropNotAllowed;\r\n                    },\r\n                    onContainerOver: function(dd, e, data){\r\n                        var me = this;\r\n                        // invalid drop target\r\n                        me.valid = false;\r\n                        return me.dropNotAllowed;\r\n                    }\r\n                });\r\n            },\r\n            drop: function(node, data, dropRec, dropPosition){\r\n                var sqlTable1, sqlTable2, showJoinCM, connection, aBBPos, join, joinCondition = '', dropTable, targetTable;\r\n\r\n                showJoinCM = function(event, el){\r\n                    var cm;\r\n                    // stop the browsers event bubbling\r\n                    event.stopEvent();\r\n                    // create context menu\r\n                    cm = Ext.create('Ext.menu.Menu', {\r\n                        items: [{\r\n                            text: 'Edit Join',\r\n                            icon: 'resources/images/document_edit16x16.gif',\r\n                            handler: Ext.Function.bind(function(){\r\n\r\n                            }, this)\r\n                        }, {\r\n                            text: 'Remove Join',\r\n                            icon: 'resources/images/remove.gif',\r\n                            handler: Ext.Function.bind(function(){\r\n                                // remove any connection lines from surface and from array ux.vqbuilder.connections\r\n                                ux.vqbuilder.connections = Ext.Array.filter(ux.vqbuilder.connections, function(connection){\r\n                                    var bRemove = true;\r\n                                    if (this.uuid == connection.uuid) {\r\n                                        this.line.remove();\r\n                                        this.bgLine.remove();\r\n                                        this.miniLine1.remove();\r\n                                        this.miniLine2.remove();\r\n                                        bRemove = false;\r\n                                    }\r\n                                    return bRemove;\r\n                                }, this);\r\n                                ux.vqbuilder.sqlSelect.removeJoinById(this.uuid);\r\n                            }, this)\r\n                        }, {\r\n                            text: 'Close Menu',\r\n                            icon: 'resources/images/cross.gif',\r\n                            handler: Ext.emptyFn\r\n                        }]\r\n                    });\r\n                    // show the contextmenu next to current mouse position\r\n                    cm.showAt(event.getXY());\r\n                };\r\n\r\n                if (node.boundView) {\r\n                    sqlTable1 = data.view.up('window');\r\n                    sqlTable1.shadowSprite.bConnections = true;\r\n\r\n                    sqlTable2 = Ext.getCmp(node.boundView).up('window');\r\n                    sqlTable2.shadowSprite.bConnections = true;\r\n\r\n                    dropTable = ux.vqbuilder.sqlSelect.getTableById(sqlTable1.tableId);\r\n                    targetTable = ux.vqbuilder.sqlSelect.getTableById(sqlTable2.tableId);\r\n\r\n                    aBBPos = [data.item.viewIndex, node.viewIndex];\r\n\r\n                    connection = sqlTable2.connection(sqlTable1.shadowSprite, sqlTable2.shadowSprite, \"#000\", aBBPos);\r\n\r\n                    sqlTable1.connectionUUIDs.push(connection.uuid);\r\n                    sqlTable2.connectionUUIDs.push(connection.uuid);\r\n\r\n                    ux.vqbuilder.connections.push(connection);\r\n\r\n                    // bgLine is white(invisble) and its stroke-width is 10\r\n                    // so it is easier to capture the dblclick event\r\n                    connection.bgLine.el.on('contextmenu', showJoinCM, connection);\r\n\r\n                    // line is black and its stroke-width is 1\r\n                    connection.line.el.on('contextmenu', showJoinCM, connection);\r\n\r\n                    // create an instance of the join model\r\n                    join = Ext.create('Ext.ux.window.visualsqlquerybuilder.SQLJoin');\r\n                    // set join id\r\n                    join.set('id', connection.uuid);\r\n                    // sqlTable1 is the left table\r\n                    join.set('leftTableId', sqlTable1.tableId);\r\n                    // data.records[0] represents the model of the dragged node\r\n                    join.set('leftTableField', data.records[0].get('field'));\r\n                    // sqlTable1 is the left table\r\n                    join.set('rightTableId', sqlTable2.tableId);\r\n                    // node.viewIndex is the index of the target node\r\n                    join.set('rightTableField', sqlTable2.down('grid').store.getAt(node.viewIndex).get('field'));\r\n                    // set the defaul join type to INNER\r\n                    join.set('joinType', 'INNER');\r\n\r\n                    if (dropTable.get('tableAlias') != '') {\r\n                        joinCondition = joinCondition + dropTable.get('tableAlias') + '.' + join.get('leftTableField') + '=';\r\n                    }\r\n                    else {\r\n                        joinCondition = joinCondition + dropTable.get('tableName') + '.' + join.get('leftTableField') + '=';\r\n                    }\r\n\r\n                    if (targetTable.get('tableAlias') != '') {\r\n                        joinCondition = joinCondition + targetTable.get('tableAlias') + '.' + join.get('rightTableField');\r\n                    }\r\n                    else {\r\n                        joinCondition = joinCondition + targetTable.get('tableName') + '.' + join.get('rightTableField');\r\n                    }\r\n\r\n                    join.set('joinCondition', joinCondition);\r\n                    ux.vqbuilder.sqlSelect.addJoin(join);\r\n                }\r\n\r\n            }\r\n        }\r\n    },\r\n    initComponent: function(){\r\n\r\n        this.columns = [{\r\n            xtype: 'gridcolumn',\r\n            width: 16,\r\n            dataIndex: 'key',\r\n            renderer: function(val, meta, model){\r\n                if (val == 'PRI') {\r\n                    meta.style = 'background-image:url(resources/images/key.gif) !important;background-position:2px 3px;background-repeat:no-repeat;';\r\n                }\r\n                return '&nbsp;';\r\n            }\r\n        }, {\r\n            xtype: 'gridcolumn',\r\n            flex: 1,\r\n            dataIndex: 'field',\r\n            renderer: function(val, meta, model){\r\n                if (model.get('key') == 'PRI') {\r\n                    return '<span style=\"font-weight: bold;\">' + val + '</span>&nbsp;&nbsp;<span style=\"color:#aaa;\">' + model.get('type') + '</span>';\r\n                }\r\n                return val + '&nbsp;&nbsp;<span style=\"color:#999;\">' + model.get('type') + '</span>';\r\n\r\n            }\r\n        }];\r\n\r\n        this.selModel = Ext.create('Ext.selection.CheckboxModel', {\r\n            mode: 'SIMPLE',\r\n            checkOnly: true,\r\n            listeners: {\r\n                select: function(selModel, data){\r\n                    // add new rows to the SQLFieldsGrid after a selection change\r\n                    ux.vqbuilder.sqlSelect.addFieldRecord(data, true);\r\n                },\r\n                deselect: function(selModel, data){\r\n                    var store, model;\r\n                    // remove row from SQLFieldsGrid after deselection\r\n                    ux.vqbuilder.sqlSelect.removeFieldById(data.get('id'));\r\n                }\r\n            }\r\n        });\r\n\r\n        this.callParent(arguments);\r\n    }\r\n});\r\n\r\nExt.define('Ext.ux.window.visualsqlquerybuilder.SQLTable', {\r\n    extend: 'Ext.window.Window',\r\n    minWidth: 120,\r\n    alias: ['widget.sqltable'],\r\n    cascadeOnFirstShow: 20,\r\n    height: 180,\r\n    width: 140,\r\n    shadowSprite: {},\r\n    layout: {\r\n        type: 'fit'\r\n    },\r\n    closable: true,\r\n    listeners: {\r\n        show: function(){\r\n            this.initSQLTable();\r\n        },\r\n        beforeclose: function(){\r\n            this.closeSQLTable();\r\n        }\r\n    },\r\n    closeSQLTable: function(){\r\n        // remove fields / columns from sqlFieldsStore\r\n        ux.vqbuilder.sqlSelect.removeFieldsByTableId(this.tableId);\r\n\r\n        // remove table from sqlTables store inside ux.vqbuilder.sqlSelect\r\n        ux.vqbuilder.sqlSelect.removeTableById(this.tableId);\r\n\r\n        // unregister mousedown event\r\n        this.getHeader().el.un('mousedown', this.regStartDrag, this);\r\n        // unregister mousemove event\r\n        Ext.EventManager.un(document, 'mousemove', this.moveWindow, this);\r\n        // remove sprite from surface\r\n        Ext.getCmp('SQLTablePanel').down('draw').surface.remove(this.shadowSprite, false);\r\n        // remove any connection lines from surface and from array ux.vqbuilder.connections\r\n        ux.vqbuilder.connections = Ext.Array.filter(ux.vqbuilder.connections, function(connection){\r\n            var bRemove = true;\r\n            for (var j = 0, l = this.connectionUUIDs.length; j < l; j++) {\r\n                if (connection.uuid == this.connectionUUIDs[j]) {\r\n                    connection.line.remove();\r\n                    connection.bgLine.remove();\r\n                    connection.miniLine1.remove();\r\n                    connection.miniLine2.remove();\r\n                    bRemove = false;\r\n                }\r\n            }\r\n            return bRemove;\r\n        }, this);\r\n\r\n    },\r\n    initSQLTable: function(){\r\n        var sqlTablePanel, xyParentPos, xyChildPos, childSize, sprite;\r\n\r\n        // get the main sqlTablePanel\r\n        sqlTablePanel = Ext.getCmp('SQLTablePanel');\r\n\r\n        // get the main sqlTablePanel position\r\n        xyParentPos = sqlTablePanel.el.getXY();\r\n\r\n        // get position of the previously added sqltable\r\n        xyChildPos = this.el.getXY();\r\n\r\n        // get the size of the previously added sqltable\r\n        childSize = this.el.getSize();\r\n\r\n        // create a sprite of type rectangle and set its position and size\r\n        // to position and size of the the sqltable\r\n        sprite = Ext.create('Ext.ux.window.visualsqlquerybuilder.SQLTableSprite', {\r\n            type: 'rect',\r\n            stroke: '#fff',\r\n            height: childSize.height - 4,\r\n            width: childSize.width - 4,\r\n            x: xyChildPos[0] - xyParentPos[0] + 2,\r\n            y: xyChildPos[1] - xyParentPos[1] + 2,\r\n            scrollTop: 0\r\n        });\r\n\r\n        // add the sprite to the surface of the sqlTablePanel\r\n        this.shadowSprite = sqlTablePanel.down('draw').surface.add(sprite).show(true);\r\n\r\n        // handle resizeing of sqltabel\r\n        this.resizer.on('resize', function(resizer, width, height, event){\r\n            this.shadowSprite.setAttributes({\r\n                width: width - 6,\r\n                height: height - 6\r\n            }, true);\r\n            // also move the associated connections\r\n            for (var i = ux.vqbuilder.connections.length; i--;) {\r\n                this.connection(ux.vqbuilder.connections[i]);\r\n            }\r\n        }, this);\r\n\r\n        // register a function for the mousedown event on the previously added sqltable and bind to this scope\r\n        this.getHeader().el.on('mousedown', this.regStartDrag, this);\r\n\r\n        this.getHeader().el.on('contextmenu', this.showSQLTableCM, this);\r\n\r\n        this.getHeader().el.on('dblclick', this.showTableAliasEditForm, this);\r\n\r\n        this.getHeader().origValue = '';\r\n\r\n        // register method this.moveWindow for the mousemove event on the document and bind to this scope\r\n        Ext.EventManager.on(document, 'mousemove', this.moveWindow, this);\r\n\r\n        // register a function for the mouseup event on the document and add the this scope\r\n        Ext.EventManager.on(document, 'mouseup', function(){\r\n            // save the mousedown state\r\n            this.bMouseDown = false;\r\n        }, this);\r\n\r\n\r\n    },\r\n    showSQLTableCM: function(event, el){\r\n        var cm;\r\n        // stop the browsers event bubbling\r\n        event.stopEvent();\r\n        // create context menu\r\n        cm = Ext.create('Ext.menu.Menu', {\r\n            items: [{\r\n                text: 'Add/Edit Alias',\r\n                icon: 'resources/images/document_edit16x16.gif',\r\n                handler: Ext.Function.bind(function(){\r\n                    this.showTableAliasEditForm();\r\n                }, this)\r\n            }, {\r\n                text: 'Remove Table',\r\n                icon: 'resources/images/delete.gif',\r\n                handler: Ext.Function.bind(function(){\r\n                    // remove the sqltable\r\n                    this.close();\r\n                }, this)\r\n            }, {\r\n                text: 'Close Menu',\r\n                icon: 'resources/images/cross.gif',\r\n                handler: Ext.emptyFn\r\n            }]\r\n        });\r\n        // show the contextmenu next to current mouse position\r\n        cm.showAt(event.getXY());\r\n    },\r\n    showTableAliasEditForm: function(event, el){\r\n        var table, header, title, titleId;\r\n        table = ux.vqbuilder.sqlSelect.getTableById(this.tableId);\r\n        header = this.getHeader();\r\n        titleId = '#' + header.getId() + '_hd';\r\n        title = this.down(titleId);\r\n        header.remove(title);\r\n        header.insert(0, [{\r\n            xtype: 'textfield',\r\n            flex: 0.95,\r\n            parentCmp: header,\r\n            parentTableModel: table,\r\n            initComponent: function(){\r\n\r\n                this.setValue(this.parentTableModel.get('tableAlias'));\r\n\r\n                this.on('render', function(field, event){\r\n                    // set focus to the textfield Benutzerkennung\r\n                    field.focus(true, 200);\r\n                }, this);\r\n\r\n                this.on('specialkey', function(field, event){\r\n                    if (event.getKey() == event.ENTER) {\r\n                        if (field.getValue() != this.parentCmp.origValue) {\r\n                            this.parentTableModel.set('tableAlias', field.getValue());\r\n                            this.parentCmp.origValue = field.getValue();\r\n                        }\r\n                        this.removeTextField();\r\n                        this.addTitle();\r\n                    }\r\n                }, this);\r\n\r\n                this.on('blur', function(field, event){\r\n                    if (field.getValue() != this.parentCmp.origValue) {\r\n                        this.parentTableModel.set('tableAlias', field.getValue());\r\n                        this.parentCmp.origValue = field.getValue();\r\n                    }\r\n                    this.removeTextField();\r\n                    this.addTitle();\r\n                }, this);\r\n\r\n                this.callParent(arguments);\r\n            },\r\n            removeTextField: function(){\r\n                var next;\r\n                next = this.next();\r\n                this.parentCmp.remove(next);\r\n                this.parentCmp.remove(this);\r\n            },\r\n            addTitle: function(){\r\n                var titleText;\r\n                if (this.parentTableModel.get('tableAlias') != '') {\r\n                    titleText = this.parentTableModel.get('tableAlias') + ' ( ' + this.parentTableModel.get('tableName') + ' )';\r\n                }\r\n                else {\r\n                    titleText = this.parentTableModel.get('tableName');\r\n                }\r\n                this.parentCmp.insert(0, {\r\n                    xtype: 'component',\r\n                    ariaRole: 'heading',\r\n                    focusable: false,\r\n                    noWrap: true,\r\n                    flex: 1,\r\n                    id: this.parentCmp.id + '_hd',\r\n                    style: 'text-align:' + this.parentCmp.titleAlign,\r\n                    cls: this.parentCmp.baseCls + '-text-container',\r\n                    renderTpl: this.parentCmp.getTpl('headingTpl'),\r\n                    renderData: {\r\n                        title: titleText,\r\n                        cls: this.parentCmp.baseCls,\r\n                        ui: this.parentCmp.ui\r\n                    },\r\n                    childEls: ['textEl']\r\n                });\r\n            }\r\n        }, {\r\n            xtype: 'component',\r\n            flex: 0.05\r\n        }]);\r\n    },\r\n    regStartDrag: function(){\r\n        // save the mousedown state\r\n        this.bMouseDown = true;\r\n        // start the drag of the sprite\r\n        this.shadowSprite.startDrag(this.getId());\r\n    },\r\n    moveWindow: function(event, domEl, opt){\r\n        var relPosMovement;\r\n        // check mousedown\r\n        if (this.bMouseDown) {\r\n            // get relative x and y values (offset)\r\n            relPosMovement = this.getOffset('point');\r\n            // move the sprite to the position of the window\r\n            this.shadowSprite.onDrag(relPosMovement);\r\n            // check if the sprite has any connections\r\n            if (this.shadowSprite.bConnections) {\r\n                // also move the associated connections\r\n                for (var i = ux.vqbuilder.connections.length; i--;) {\r\n                    this.connection(ux.vqbuilder.connections[i]);\r\n                }\r\n            }\r\n        }\r\n    },\r\n    getLeftRightCoordinates: function(obj1, obj2, aBBPos){\r\n        var bb1, bb2, p = [], dx, leftBoxConnectionPoint, rightBoxConnectionPoint, dis, columHeight = 21, headerHeight = 46, LeftRightCoordinates = {};\r\n\r\n        // BoundingBox Koordinaten f√ºr beide Sprites abrufen\r\n\r\n        bb1 = obj1.getBBox();\r\n        // y Wert f√ºr connection Points auf der linken und rechten Seite von bb1\r\n        bb1.pY = bb1.y + headerHeight + ((aBBPos[0] - 1) * columHeight) + (columHeight / 2) - obj1.scrollTop;\r\n\r\n        bb2 = obj2.getBBox();\r\n        // y Wert f√ºr connection Points auf der linken und rechten Seite von bb2\r\n        bb2.pY = bb2.y + headerHeight + ((aBBPos[1] - 1) * columHeight) + (columHeight / 2) - obj2.scrollTop;\r\n\r\n        // code f√ºr linke boundingBox\r\n        if (bb1.pY > (bb1.y + 4) && bb1.pY < (bb1.y + bb1.height - 4)) {\r\n            p.push({\r\n                x: bb1.x - 1, // Punkt auf linker Seite auf H√∂he der verkn√ºpften Spalte\r\n                y: bb1.pY\r\n            });\r\n            p.push({\r\n                x: bb1.x + bb1.width + 1, // Punkt auf rechter Seite auf H√∂he der verkn√ºpften Spalte\r\n                y: bb1.pY\r\n            });\r\n        }\r\n        else {\r\n            if (bb1.pY < (bb1.y + 4)) {\r\n                p.push({\r\n                    x: bb1.x - 1, // Punkt auf linker Seite max. obere Position\r\n                    y: bb1.y + 4\r\n                });\r\n                p.push({\r\n                    x: bb1.x + bb1.width + 1, // Punkt auf rechter Seite max. obere Position\r\n                    y: bb1.y + 4\r\n                });\r\n            }\r\n            else {\r\n                p.push({\r\n                    x: bb1.x - 1, // Punkt auf linker Seite max. untere Position\r\n                    y: bb1.y + bb1.height - 4\r\n                });\r\n                p.push({\r\n                    x: bb1.x + bb1.width + 1, // Punkt auf rechter Seite max. untere Position\r\n                    y: bb1.y + bb1.height - 4\r\n                });\r\n            };\r\n                    };\r\n\r\n        //  code f√ºr rechte boundingBox\r\n        if (bb2.pY > (bb2.y + 4) && bb2.pY < (bb2.y + bb2.height - 4)) {\r\n            p.push({\r\n                x: bb2.x - 1, // Punkt auf linker Seite auf H√∂he der verkn√ºpften Spalte\r\n                y: bb2.pY\r\n            });\r\n            p.push({\r\n                x: bb2.x + bb2.width + 1, // Punkt auf rechter Seite auf H√∂he der verkn√ºpften Spalte\r\n                y: bb2.pY\r\n            });\r\n        }\r\n        else {\r\n            if (bb2.pY < (bb2.y + 4)) {\r\n                p.push({\r\n                    x: bb2.x - 1, // Punkt auf linker Seite max. obere Position\r\n                    y: bb2.y + 4\r\n                });\r\n                p.push({\r\n                    x: bb2.x + bb2.width + 1, // Punkt auf rechter Seite max. obere Position\r\n                    y: bb2.y + 4\r\n                });\r\n            }\r\n            else {\r\n                p.push({\r\n                    x: bb2.x - 1, // Punkt auf linker Seite max. untere Position\r\n                    y: bb2.y + bb2.height - 4\r\n                });\r\n\r\n                p.push({\r\n                    x: bb2.x + bb2.width + 1, // Punkt auf rechter Seite max. untere Position\r\n                    y: bb2.y + bb2.height - 4\r\n                });\r\n            }\r\n        };\r\n\r\n        // Schleife √ºber die Punkte der ersten BoundingBox\r\n        for (var i = 0; i < 2; i++) {\r\n            // Schleife √ºber die Punkte der zweiten BoundingBox\r\n            for (var j = 2; j < 4; j++) {\r\n                // Berechnung der Offsets zwischen den jeweils vier Punkten beider BoundingBoxes\r\n                dx = Math.abs(p[i].x - p[j].x), dy = Math.abs(p[i].y - p[j].y);\r\n                // bb1 links mit bb2 rechts\r\n                if (((i == 0 && j == 3) && dx < Math.abs(p[1].x - p[2].x)) || ((i == 1 && j == 2) && dx < Math.abs(p[0].x - p[3].x))) {\r\n                    leftBoxConnectionPoint = p[i];\r\n                    rightBoxConnectionPoint = p[j];\r\n                }\r\n            }\r\n        };\r\n\r\n        return {\r\n            leftBoxConnectionPoint: leftBoxConnectionPoint,\r\n            rightBoxConnectionPoint: rightBoxConnectionPoint\r\n        };\r\n\r\n    },\r\n    connection: function(obj1, obj2, line, aBBPos){\r\n        var LeftRightCoordinates, line1, line2, miniLine1, miniLine2, path, surface, color = typeof line == \"string\" ? line : \"#000\";\r\n\r\n        if (obj1.line && obj1.from && obj1.to && obj1.aBBPos) {\r\n            line = obj1;\r\n            obj1 = line.from;\r\n            obj2 = line.to;\r\n            aBBPos = line.aBBPos;\r\n        }\r\n\r\n        // set reference to the wright surface\r\n        surface = obj1.surface;\r\n\r\n        // get coordinates for the left and right box\r\n        LeftRightCoordinates = this.getLeftRightCoordinates(obj1, obj2, aBBPos);\r\n\r\n        // check if the LeftBox is still on the left side or not\r\n        if (LeftRightCoordinates.leftBoxConnectionPoint.x - LeftRightCoordinates.rightBoxConnectionPoint.x < 0) {\r\n            line1 = 12;\r\n            line2 = 12;\r\n        }\r\n        else {\r\n            line1 = -12;\r\n            line2 = -12;\r\n        }\r\n        // define the path between the left and the right box\r\n        path = [\"M\", LeftRightCoordinates.leftBoxConnectionPoint.x, LeftRightCoordinates.leftBoxConnectionPoint.y, \"H\", LeftRightCoordinates.leftBoxConnectionPoint.x + line1, \"L\", LeftRightCoordinates.rightBoxConnectionPoint.x - line2, LeftRightCoordinates.rightBoxConnectionPoint.y, \"H\", LeftRightCoordinates.rightBoxConnectionPoint.x].join(\",\");\r\n\r\n        miniLine1 = [\"M\", LeftRightCoordinates.leftBoxConnectionPoint.x, LeftRightCoordinates.leftBoxConnectionPoint.y, \"H\", LeftRightCoordinates.leftBoxConnectionPoint.x + line1].join(\",\");\r\n\r\n        miniLine2 = [\"M\", LeftRightCoordinates.rightBoxConnectionPoint.x - line2, LeftRightCoordinates.rightBoxConnectionPoint.y, \"H\", LeftRightCoordinates.rightBoxConnectionPoint.x].join(\",\");\r\n\r\n        //check if it is a new connection or not\r\n        if (line && line.line) {\r\n            // old connection, only change path\r\n            line.bgLine &&\r\n            line.bgLine.setAttributes({\r\n                path: path\r\n            }, true);\r\n            line.line.setAttributes({\r\n                path: path\r\n            }, true);\r\n            line.miniLine1.setAttributes({\r\n                path: miniLine1\r\n            }, true);\r\n            line.miniLine2.setAttributes({\r\n                path: miniLine2\r\n            }, true);\r\n        }\r\n        else {\r\n            // new connction, return new connection object\r\n            return {\r\n                line: Ext.create('Ext.draw.Sprite', {\r\n                    type: 'path',\r\n                    path: path,\r\n                    stroke: color,\r\n                    fill: 'none',\r\n                    'stroke-width': 1,\r\n                    surface: surface\r\n                }).show(true),\r\n                miniLine1: Ext.create('Ext.draw.Sprite', {\r\n                    type: 'path',\r\n                    path: miniLine1,\r\n                    stroke: color,\r\n                    fill: 'none',\r\n                    'stroke-width': 2,\r\n                    surface: surface\r\n                }).show(true),\r\n                miniLine2: Ext.create('Ext.draw.Sprite', {\r\n                    type: 'path',\r\n                    path: miniLine2,\r\n                    stroke: color,\r\n                    fill: 'none',\r\n                    'stroke-width': 2,\r\n                    surface: surface\r\n                }).show(true),\r\n                bgLine: Ext.create('Ext.draw.Sprite', {\r\n                    type: 'path',\r\n                    path: path,\r\n                    opacity: 0,\r\n                    stroke: '#fff',\r\n                    fill: 'none',\r\n                    'stroke-width': 10,\r\n                    surface: surface\r\n                }).show(true),\r\n                from: obj1,\r\n                to: obj2,\r\n                aBBPos: aBBPos,\r\n                uuid: this.createUUID()\r\n            };\r\n        }\r\n    },\r\n    initComponent: function(){\r\n        var store, tableModel;\r\n\r\n        this.connectionUUIDs = [];\r\n        this.bMouseDown = false;\r\n\r\n        // asign a uuid to the window, this builds relationship with sqlTable\r\n        this.tableId = this.createUUID();\r\n\r\n\r\n        store = Ext.create('Ext.data.Store', {\r\n            autoLoad: true,\r\n            fields: [{\r\n                name: 'id',\r\n                type: 'string'\r\n            }, {\r\n                name: 'tableName',\r\n                type: 'string'\r\n            }, {\r\n                name: 'tableId',\r\n                type: 'string',\r\n                defaultValue: this.tableId\r\n            }, {\r\n                name: 'field',\r\n                type: 'string'\r\n            }, {\r\n                name: 'extCmpId',\r\n                type: 'string',\r\n                defaultValue: this.id\r\n            }, {\r\n                name: 'type',\r\n                type: 'string'\r\n            }, {\r\n                name: 'null',\r\n                type: 'string'\r\n            }, {\r\n                name: 'key',\r\n                type: 'string'\r\n            }, {\r\n                name: 'default',\r\n                type: 'string'\r\n            }, {\r\n                name: 'extra',\r\n                type: 'string'\r\n            }],\r\n            proxy: {\r\n                type: 'local',\r\n                reader: {\r\n                    type: 'json',\r\n                    root: 'items'\r\n                }\r\n            },\r\n            data: { items: [{ \"field\": \"*\", \"extra\": \"\", \"id\": \"D04A39CB-AF22-A5F3-0246BA11FD51BCD8\", \"key\": \"\", \"tableName\": \"bestellung\", \"null\": \"\", \"default\": \"\", \"type\": \"\" }, { \"field\": \"bestell_id\", \"extra\": \"auto_increment\", \"id\": \"D04A39CC-E436-C0BE-1D51AEF07A7A5AAF\", \"key\": \"PRI\", \"tableName\": \"bestellung\", \"null\": false, \"default\": \"\", \"type\": \"int(11)\" }, { \"field\": \"bestell_datum\", \"extra\": \"\", \"id\": \"D04A39CD-E13A-7228-81930472A5FC49AE\", \"key\": \"\", \"tableName\": \"bestellung\", \"null\": true, \"default\": \"\", \"type\": \"datetime\" }, { \"field\": \"bname\", \"extra\": \"\", \"id\": \"D04A39CE-04F3-D1CE-A1D72B04F40920C2\", \"key\": \"MUL\", \"tableName\": \"bestellung\", \"null\": true, \"default\": \"\", \"type\": \"varchar(255)\" }] }\r\n        });\r\n\r\n        // add sql table to ux.vqbuilder.sqlSelect tables store\r\n        // also asign same id as stores uuid\r\n        tableModel = Ext.create('Ext.ux.window.visualsqlquerybuilder.SQLTableModel', {\r\n            id: this.tableId,\r\n            tableName: this.title,\r\n            tableAlias: ''\r\n        });\r\n        ux.vqbuilder.sqlSelect.addTable(tableModel);\r\n\r\n        this.items = [{\r\n            xtype: 'sqltablegrid',\r\n            store: store\r\n        }];\r\n\r\n        this.callParent(arguments);\r\n    },\r\n    getOffset: function(constrain){\r\n        var xy = this.dd.getXY(constrain), s = this.dd.startXY;\r\n        // return the the difference between the current and the drag&drop start position\r\n        return [xy[0] - s[0], xy[1] - s[1]];\r\n    },\r\n    createUUID: function(){\r\n        // http://www.ietf.org/rfc/rfc4122.txt\r\n        var s = [];\r\n        var hexDigits = \"0123456789abcdef\";\r\n        for (var i = 0; i < 36; i++) {\r\n            s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);\r\n        }\r\n        s[14] = \"4\"; // bits 12-15 of the time_hi_and_version field to 0010\r\n        s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1); // bits 6-7 of the clock_seq_hi_and_reserved to 01\r\n        s[8] = s[13] = s[18] = s[23] = \"-\";\r\n\r\n        var uuid = s.join(\"\");\r\n        return uuid;\r\n    },\r\n    beforeShow: function(){\r\n        var aWin, prev, o;\r\n        // cascading window positions\r\n        if (this.cascadeOnFirstShow) {\r\n            o = (typeof this.cascadeOnFirstShow == 'number') ? this.cascadeOnFirstShow : 20;\r\n            // get all instances from xtype sqltable\r\n            aWin = Ext.ComponentQuery.query('sqltable');\r\n            // start position if there is only one table\r\n            if (aWin.length == 1) {\r\n                this.x = o;\r\n                this.y = o;\r\n            }\r\n            else {\r\n                // loop through all instances from xtype sqltable\r\n                for (var i = 0, l = aWin.length; i < l; i++) {\r\n                    if (aWin[i] == this) {\r\n                        if (prev) {\r\n                            this.x = prev.x + o;\r\n                            this.y = prev.y + o;\r\n                        }\r\n                    }\r\n                    if (aWin[i].isVisible()) {\r\n                        prev = aWin[i];\r\n                    }\r\n                }\r\n            }\r\n            this.setPosition(this.x, this.y);\r\n        }\r\n    }\r\n});\r\n\r\nExt.define('Ext.ux.window.VisualSQLQueryBuilder', {\r\n    extend: 'Ext.window.Window',\r\n    alias: ['widget.qbwindow'],\r\n    height: 620,\r\n    width: 1000,\r\n    layout: {\r\n        type: 'border'\r\n    },\r\n    title: 'Visual SQL Query Builder',\r\n    items: [{\r\n        xtype: 'sqloutputpanel',\r\n        border: false,\r\n        region: 'center',\r\n        autoScroll: true,\r\n        html: '<pre class=\"brush: sql\">SQL Output Window</pre>',\r\n        margin: 5,\r\n        height: 150,\r\n        split: true\r\n    }, {\r\n        xtype: 'panel',\r\n        border: false,\r\n        height: 400,\r\n        margin: 5,\r\n        layout: {\r\n            type: 'border'\r\n        },\r\n        region: 'north',\r\n        split: true,\r\n        items: [{\r\n            xtype: 'sqltablepanel',\r\n            border: false,\r\n            region: 'center',\r\n            height: 280,\r\n            split: true,\r\n            layout: 'fit'\r\n        }, {\r\n            xtype: 'sqlfieldsgrid',\r\n            border: false,\r\n            region: 'south',\r\n            height: 120,\r\n            split: true\r\n        }, {\r\n            xtype: 'sqltabletree',\r\n            border: false,\r\n            region: 'west',\r\n            width: 200,\r\n            height: 400,\r\n            split: true\r\n        }]\r\n    }],\r\n    initComponent: function(){\r\n\r\n        // create user extension namespace ux.vqbuilder\r\n        Ext.namespace('ux.vqbuilder');\r\n\r\n        // disable gutter (linenumbers) and toolbar for SyntaxHighlighter\r\n        SyntaxHighlighter.defaults['gutter'] = false;\r\n        SyntaxHighlighter.defaults['toolbar'] = false;\r\n\r\n        ux.vqbuilder.connections = [];\r\n\r\n        ux.vqbuilder.sqlSelect = Ext.create('Ext.ux.window.visualsqlquerybuilder.SQLSelect');\r\n\r\n        // add toolbar to the dockedItems\r\n        this.dockedItems = [{\r\n            xtype: 'toolbar',\r\n            dock: 'top',\r\n            items: [{\r\n                xtype: 'tbfill'\r\n            }, {\r\n                text: \"Save\",\r\n                icon: \"resources/images/icon-save.gif\"\r\n            }, {\r\n                text: \"Run\",\r\n                icon: \"resources/images/run.png\"\r\n            }]\r\n        }];\r\n\r\n        this.callParent(arguments);\r\n    }\r\n});\r\n\r\n//@ sourceURL=extjs/src/ux/window/VisualSQLQueryBuilder.js"]],"start1":0,"start2":0,"length1":0,"length2":73145}]],"length":73145}
